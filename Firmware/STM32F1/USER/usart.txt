; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --execute_only --list --split_sections --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\KEY -I..\HARDWARE\TIMER -I..\SYSTEM\bsptime -I..\SYSTEM\IM1281B -I.\RTE\_PWM -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\usart.crf ..\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, EXECONLY, ALIGN=1

                  USART1_IRQHandler PROC
;;;121    
;;;122    void USART1_IRQHandler(void){//串口1中断服务程序
000000  b510              PUSH     {r4,lr}
;;;123    	u8 Res;
;;;124    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET){
000002  f44f5460          MOV      r4,#0x3800
000006  f2c40401          MOVT     r4,#0x4001
00000a  f2405125          MOV      r1,#0x525
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_GetITStatus
000014  2800              CMP      r0,#0
000016  d032              BEQ      |L1.126|
;;;125    		Res = USART_ReceiveData(USART1);//读取接收到的数据
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       USART_ReceiveData
00001e  b2c1              UXTB     r1,r0
;;;126    		if((USART1_RX_STA&0x8000)==0){//接收未完成
000020  f2400000          MOVW     r0,#:LOWER16: ||.data||
000024  f2c00000          MOVT     r0,#:UPPER16: ||.data||
000028  8802              LDRH     r2,[r0,#0]  ; USART1_RX_STA
00002a  0412              LSLS     r2,r2,#16
00002c  d427              BMI      |L1.126|
;;;127    			
;;;128    			if(USART1_RX_STA&0x4000){//接收到了数据长度位
00002e  8802              LDRH     r2,[r0,#0]  ; USART1_RX_STA
000030  0453              LSLS     r3,r2,#17
;;;129    				if((USART1_RX_STA&0X3FFF) == USART1_RX_BUF[2]+4){
000032  f2400200          MOVW     r2,#:LOWER16: ||.bss||
000036  f2c00200          MOVT     r2,#:UPPER16: ||.bss||
;;;130    					//收到了足够长的数据，认为ok了
;;;131    					USART1_RX_STA|=0x8000;
;;;132    				}
;;;133    			}
;;;134    			else if((USART1_RX_STA&0X3FFF) == 3){
00003a  8803              LDRH     r3,[r0,#0]  ; USART1_RX_STA
00003c  d509              BPL      |L1.82|
00003e  f3c3040d          UBFX     r4,r3,#0,#14          ;129
000042  7893              LDRB     r3,[r2,#2]            ;129  ; USART1_RX_BUF
000044  1d1b              ADDS     r3,r3,#4              ;129
000046  429c              CMP      r4,r3                 ;129
000048  d10b              BNE      |L1.98|
00004a  8803              LDRH     r3,[r0,#0]            ;131  ; USART1_RX_STA
00004c  f4434300          ORR      r3,r3,#0x8000         ;131
000050  e006              B        |L1.96|
                  |L1.82|
000052  f3c3030d          UBFX     r3,r3,#0,#14
000056  2b03              CMP      r3,#3
000058  d103              BNE      |L1.98|
;;;135    				USART1_RX_STA|=0x4000;//长度够了，认为收到了长度位
00005a  8803              LDRH     r3,[r0,#0]  ; USART1_RX_STA
00005c  f4434380          ORR      r3,r3,#0x4000
                  |L1.96|
000060  8003              STRH     r3,[r0,#0]
                  |L1.98|
;;;136    			}
;;;137    			
;;;138    			USART1_RX_BUF[USART1_RX_STA&0X3FFF]=Res;
000062  8803              LDRH     r3,[r0,#0]  ; USART1_RX_STA
000064  f3c3030d          UBFX     r3,r3,#0,#14
000068  54d1              STRB     r1,[r2,r3]
;;;139    			USART1_RX_STA++;
00006a  8801              LDRH     r1,[r0,#0]  ; USART1_RX_STA
00006c  1c49              ADDS     r1,r1,#1
00006e  8001              STRH     r1,[r0,#0]
;;;140    			if((USART1_RX_STA&0X3FFF)>(USART1_REC_LEN-1))	USART1_RX_STA=0;//接收数据错误,重新开始接收
000070  8801              LDRH     r1,[r0,#0]  ; USART1_RX_STA
000072  f3c1010d          UBFX     r1,r1,#0,#14
000076  2927              CMP      r1,#0x27
000078  d901              BLS      |L1.126|
00007a  2100              MOVS     r1,#0
00007c  8001              STRH     r1,[r0,#0]
                  |L1.126|
;;;141    		}
;;;142    	}
;;;143    }
00007e  bd10              POP      {r4,pc}
;;;144    
                          ENDP


                          AREA ||i.USART2_IRQHandler||, CODE, EXECONLY, ALIGN=1

                  USART2_IRQHandler PROC
;;;144    
;;;145    void USART2_IRQHandler(void){//串口2中断服务程序
000000  b510              PUSH     {r4,lr}
;;;146    	//注意,读取USARTx->SR能避免莫名其妙的错误  
;;;147    	u8 Res;
;;;148    	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000002  f44f4488          MOV      r4,#0x4400
000006  f2c40400          MOVT     r4,#0x4000
00000a  f2405125          MOV      r1,#0x525
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_GetITStatus
000014  2800              CMP      r0,#0
000016  d012              BEQ      |L2.62|
;;;149    		{
;;;150    		Res = USART_ReceiveData(USART2);	//读取接收到的数据
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       USART_ReceiveData
00001e  b2c0              UXTB     r0,r0
;;;151    		
;;;152    		if((USART2_RX_STA&0x8000)==0)//接收未完成
000020  f2400100          MOVW     r1,#:LOWER16: ||.data||
000024  f2c00100          MOVT     r1,#:UPPER16: ||.data||
000028  884a              LDRH     r2,[r1,#2]  ; USART2_RX_STA
00002a  0412              LSLS     r2,r2,#16
00002c  d407              BMI      |L2.62|
;;;153    			{
;;;154    			if(USART2_RX_STA&0x4000)//接收到了0x0d
00002e  884a              LDRH     r2,[r1,#2]  ; USART2_RX_STA
000030  0453              LSLS     r3,r2,#17
000032  f04f0200          MOV      r2,#0
000036  d507              BPL      |L2.72|
;;;155    				{
;;;156    				if(Res!=0x0a)USART2_RX_STA=0;//接收错误,重新开始
000038  280a              CMP      r0,#0xa
00003a  d001              BEQ      |L2.64|
                  |L2.60|
00003c  804a              STRH     r2,[r1,#2]
                  |L2.62|
;;;157    				else USART2_RX_STA|=0x8000;	//接收完成了 
;;;158    				}
;;;159    			else //还没收到0X0D
;;;160    				{	
;;;161    				if(Res==0x0d)USART2_RX_STA|=0x4000;
;;;162    				else
;;;163    					{
;;;164    					USART2_RX_BUF[USART2_RX_STA&0X3FFF]=Res ;
;;;165    					USART2_RX_STA++;
;;;166    					if(USART2_RX_STA>(USART2_REC_LEN-1))USART2_RX_STA=0;//接收数据错误,重新开始接收	  
;;;167    					}		 
;;;168    				}
;;;169    			}   		 
;;;170         }
;;;171    } 
00003e  bd10              POP      {r4,pc}
                  |L2.64|
000040  8848              LDRH     r0,[r1,#2]            ;157  ; USART2_RX_STA
000042  f4404000          ORR      r0,r0,#0x8000         ;157
000046  e013              B        |L2.112|
                  |L2.72|
000048  280d              CMP      r0,#0xd               ;161
00004a  d00e              BEQ      |L2.106|
00004c  884b              LDRH     r3,[r1,#2]            ;164  ; USART2_RX_STA
00004e  f3c3030d          UBFX     r3,r3,#0,#14          ;164
000052  f2400400          MOVW     r4,#:LOWER16: ||.bss||+40;164
000056  f2c00400          MOVT     r4,#:UPPER16: ||.bss||+40;164
00005a  54e0              STRB     r0,[r4,r3]            ;164
00005c  8848              LDRH     r0,[r1,#2]            ;165  ; USART2_RX_STA
00005e  1c40              ADDS     r0,r0,#1              ;165
000060  8048              STRH     r0,[r1,#2]            ;165
000062  8848              LDRH     r0,[r1,#2]            ;166  ; USART2_RX_STA
000064  28c7              CMP      r0,#0xc7              ;166
000066  d8e9              BHI      |L2.60|
000068  bd10              POP      {r4,pc}
                  |L2.106|
00006a  8848              LDRH     r0,[r1,#2]            ;161  ; USART2_RX_STA
00006c  f4404080          ORR      r0,r0,#0x4000         ;161
                  |L2.112|
000070  8048              STRH     r0,[r1,#2]            ;157
000072  bd10              POP      {r4,pc}
;;;172    
                          ENDP


                          AREA ||i._sys_exit||, CODE, EXECONLY, ALIGN=1

                  _sys_exit PROC
;;;13     //定义_sys_exit()以避免使用半主机模式    
;;;14     void _sys_exit(int x) 
000000  4770              BX       lr
;;;15     { 
;;;16     	x = x; 
;;;17     } 
;;;18     
                          ENDP


                          AREA ||i.fputc||, CODE, EXECONLY, ALIGN=1

                  fputc PROC
;;;19     //重定义fputc函数 
;;;20     int fputc(int ch, FILE *f)
000000  f44f4188          MOV      r1,#0x4400
;;;21     {      
;;;22     	while((USART2->SR&0X40)==0){}//循环发送,直到发送完毕   
000004  f2c40100          MOVT     r1,#0x4000
                  |L4.8|
000008  880a              LDRH     r2,[r1,#0]
00000a  0652              LSLS     r2,r2,#25
00000c  d5fc              BPL      |L4.8|
;;;23         USART2->DR = (u8) ch;      
00000e  f2444204          MOV      r2,#0x4404
000012  f2c40200          MOVT     r2,#0x4000
000016  b2c1              UXTB     r1,r0
000018  8011              STRH     r1,[r2,#0]
;;;24     	return ch;
;;;25     }
00001a  4770              BX       lr
;;;26      	
                          ENDP


                          AREA ||i.uart1_init||, CODE, EXECONLY, ALIGN=1

                  uart1_init PROC
;;;40     
;;;41     void uart1_init(u32 bound){
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  b086              SUB      sp,sp,#0x18
;;;42     	//GPIO端口设置
;;;43     	GPIO_InitTypeDef GPIO_InitStructure;
;;;44     	USART_InitTypeDef USART_InitStructure;
;;;45     	NVIC_InitTypeDef NVIC_InitStructure;
;;;46     	 
;;;47     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;48     	
;;;49     	//USART1_TX   GPIOA.9
;;;50     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0010          STRH     r0,[sp,#0x10]
;;;51     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2403              MOVS     r4,#3
00001a  f88d4012          STRB     r4,[sp,#0x12]
;;;52     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00001e  2018              MOVS     r0,#0x18
;;;53     	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000020  f44f6600          MOV      r6,#0x800
000024  f88d0013          STRB     r0,[sp,#0x13]         ;52
000028  f2c40601          MOVT     r6,#0x4001
00002c  a904              ADD      r1,sp,#0x10
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       GPIO_Init
;;;54        
;;;55     	//USART1_RX	  GPIOA.10初始化
;;;56     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
000034  1530              ASRS     r0,r6,#20
000036  f8ad0010          STRH     r0,[sp,#0x10]
;;;57     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
00003a  2004              MOVS     r0,#4
00003c  f88d0013          STRB     r0,[sp,#0x13]
;;;58     	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
000040  a904              ADD      r1,sp,#0x10
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       GPIO_Init
;;;59     
;;;60     	//Usart1 NVIC 配置
;;;61     	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000048  2025              MOVS     r0,#0x25
00004a  f88d0014          STRB     r0,[sp,#0x14]
;;;62     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3
00004e  f88d4015          STRB     r4,[sp,#0x15]
;;;63     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
000052  f88d4016          STRB     r4,[sp,#0x16]
;;;64     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000056  2001              MOVS     r0,#1
000058  f88d0017          STRB     r0,[sp,#0x17]
;;;65     	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00005c  a805              ADD      r0,sp,#0x14
00005e  f7fffffe          BL       NVIC_Init
;;;66       
;;;67     	//USART 初始化设置
;;;68     
;;;69     	USART_InitStructure.USART_BaudRate = bound;//串口波特率
;;;70     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000062  2000              MOVS     r0,#0
000064  f8ad0004          STRH     r0,[sp,#4]
;;;71     	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000068  f8ad0006          STRH     r0,[sp,#6]
;;;72     	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00006c  f8ad0008          STRH     r0,[sp,#8]
;;;73     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000070  f8ad000c          STRH     r0,[sp,#0xc]
;;;74     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000074  200c              MOVS     r0,#0xc
;;;75     
;;;76     	USART_Init(USART1, &USART_InitStructure); //初始化串口1
000076  f44f5460          MOV      r4,#0x3800
00007a  f8ad000a          STRH     r0,[sp,#0xa]          ;74
00007e  f2c40401          MOVT     r4,#0x4001
000082  9500              STR      r5,[sp,#0]            ;70
000084  4669              MOV      r1,sp
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       USART_Init
;;;77     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
00008c  2201              MOVS     r2,#1
00008e  f2405125          MOV      r1,#0x525
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       USART_ITConfig
;;;78     	USART_Cmd(USART1, ENABLE);//使能串口1
000098  2101              MOVS     r1,#1
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       USART_Cmd
;;;79     	}
0000a0  b006              ADD      sp,sp,#0x18
0000a2  bd70              POP      {r4-r6,pc}
;;;80     
                          ENDP


                          AREA ||i.uart2_init||, CODE, EXECONLY, ALIGN=1

                  uart2_init PROC
;;;80     
;;;81     void uart2_init(u32 bound){
000000  b5f0              PUSH     {r4-r7,lr}
000002  4607              MOV      r7,r0
000004  b087              SUB      sp,sp,#0x1c
;;;82     	//GPIO端口设置
;;;83     	GPIO_InitTypeDef GPIO_InitStructure;
;;;84     	USART_InitTypeDef USART_InitStructure;
;;;85     	NVIC_InitTypeDef NVIC_InitStructure;
;;;86     	 
;;;87     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//使能GPIOA时钟
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;88     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);//使能USART2时钟
00000e  2101              MOVS     r1,#1
000010  0448              LSLS     r0,r1,#17
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;89     	
;;;90     	//USART2_TX   GPIOA.2
;;;91     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA.2
000016  2504              MOVS     r5,#4
000018  f8ad5010          STRH     r5,[sp,#0x10]
;;;92     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2403              MOVS     r4,#3
00001e  f88d4012          STRB     r4,[sp,#0x12]
;;;93     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
000022  2018              MOVS     r0,#0x18
;;;94     	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.2
000024  f44f6600          MOV      r6,#0x800
000028  f88d0013          STRB     r0,[sp,#0x13]         ;93
00002c  f2c40601          MOVT     r6,#0x4001
000030  a904              ADD      r1,sp,#0x10
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       GPIO_Init
;;;95        
;;;96     	//USART2_RX	  GPIOA.3
;;;97     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA10
000038  2008              MOVS     r0,#8
00003a  f8ad0010          STRH     r0,[sp,#0x10]
;;;98     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
00003e  f88d5013          STRB     r5,[sp,#0x13]
;;;99     	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.3
000042  a904              ADD      r1,sp,#0x10
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       GPIO_Init
;;;100    
;;;101    	//Usart2 NVIC 配置
;;;102    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
00004a  2026              MOVS     r0,#0x26
00004c  f88d0014          STRB     r0,[sp,#0x14]
;;;103    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3
000050  f88d4015          STRB     r4,[sp,#0x15]
;;;104    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
000054  f88d4016          STRB     r4,[sp,#0x16]
;;;105    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000058  2001              MOVS     r0,#1
00005a  f88d0017          STRB     r0,[sp,#0x17]
;;;106    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00005e  a805              ADD      r0,sp,#0x14
000060  f7fffffe          BL       NVIC_Init
;;;107      
;;;108    	//USART 初始化设置
;;;109    
;;;110    	USART_InitStructure.USART_BaudRate = bound;//串口波特率
;;;111    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000064  2000              MOVS     r0,#0
000066  f8ad0004          STRH     r0,[sp,#4]
;;;112    	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
00006a  f8ad0006          STRH     r0,[sp,#6]
;;;113    	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00006e  f8ad0008          STRH     r0,[sp,#8]
;;;114    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000072  f8ad000c          STRH     r0,[sp,#0xc]
;;;115    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000076  200c              MOVS     r0,#0xc
;;;116    
;;;117    	USART_Init(USART2, &USART_InitStructure); //初始化串口2
000078  f44f4488          MOV      r4,#0x4400
00007c  f8ad000a          STRH     r0,[sp,#0xa]          ;115
000080  f2c40400          MOVT     r4,#0x4000
000084  9700              STR      r7,[sp,#0]            ;111
000086  4669              MOV      r1,sp
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       USART_Init
;;;118    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启串口接受中断
00008e  2201              MOVS     r2,#1
000090  f2405125          MOV      r1,#0x525
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       USART_ITConfig
;;;119    	USART_Cmd(USART2, ENABLE);//使能串口2
00009a  2101              MOVS     r1,#1
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       USART_Cmd
;;;120    }
0000a2  b007              ADD      sp,sp,#0x1c
0000a4  bdf0              POP      {r4-r7,pc}
;;;121    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART1_RX_BUF
                          %        40
                  USART2_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART1_RX_STA
000000  0000              DCW      0x0000
                  USART2_RX_STA
000002  0000              DCW      0x0000

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  __stdout
                          DCD      0x00000000
