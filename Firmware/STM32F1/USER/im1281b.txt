; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --execute_only --list --split_sections --debug -c --asm --interleave -o..\obj\im1281b.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\im1281b.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\KEY -I..\HARDWARE\TIMER -I..\SYSTEM\bsptime -I..\SYSTEM\IM1281B -I.\RTE\_PWM -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\im1281b.crf ..\SYSTEM\IM1281B\IM1281B.c]
                          THUMB

                          AREA ||i.calccrc||, CODE, EXECONLY, ALIGN=1

                  calccrc PROC
;;;8      
;;;9      uint16_t calccrc(uint8_t crcbuf, uint16_t crc)
000000  4048              EORS     r0,r0,r1
;;;10     {
;;;11         uint8_t i;
;;;12         uint8_t chk;
;;;13         crc = crc ^ crcbuf;
;;;14         for (i = 0; i < 8; i++)
000002  2100              MOVS     r1,#0
;;;15         {
;;;16             chk = (uint8_t)(crc & 1);
;;;17             crc = crc >> 1;
;;;18             crc = crc & 0x7fff;
;;;19             if (chk == 1)
;;;20                 crc = crc ^ 0xa001;
000004  f24a0301          MOV      r3,#0xa001
                  |L1.8|
000008  f0100f01          TST      r0,#1                 ;16
00000c  ea4f0050          LSR      r0,r0,#1              ;17
000010  d000              BEQ      |L1.20|
000012  4058              EORS     r0,r0,r3
                  |L1.20|
000014  1c49              ADDS     r1,r1,#1
000016  b2c9              UXTB     r1,r1                 ;14
000018  2908              CMP      r1,#8                 ;14
00001a  d3f5              BCC      |L1.8|
;;;21             crc = crc & 0xffff;
;;;22         }
;;;23         return crc;
;;;24     }
00001c  4770              BX       lr
;;;25     
                          ENDP


                          AREA ||i.chkcrc||, CODE, EXECONLY, ALIGN=1

                  chkcrc PROC
;;;25     
;;;26     uint16_t chkcrc(uint8_t *buf, uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;27     {
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
;;;28         uint8_t hi, lo;
;;;29         uint16_t i;
;;;30         uint16_t crc;
;;;31         crc = 0xFFFF;
000006  f64f71ff          MOV      r1,#0xffff
;;;32         for (i = 0; i < len; i++)
00000a  2400              MOVS     r4,#0
00000c  e006              B        |L2.28|
                  |L2.14|
;;;33         {
;;;34             crc = calccrc(*buf, crc);
00000e  7828              LDRB     r0,[r5,#0]
000010  f7fffffe          BL       calccrc
000014  1c64              ADDS     r4,r4,#1
000016  4601              MOV      r1,r0
000018  b2a4              UXTH     r4,r4                 ;32
00001a  1c6d              ADDS     r5,r5,#1              ;32
                  |L2.28|
00001c  42b4              CMP      r4,r6                 ;32
00001e  d3f6              BCC      |L2.14|
;;;35             buf++;
;;;36         }
;;;37         hi = (uint8_t)(crc % 256);
000020  b2c8              UXTB     r0,r1
;;;38         lo = (uint8_t)(crc / 256);
000022  0a09              LSRS     r1,r1,#8
;;;39         crc = (((uint16_t)(hi)) << 8) | lo;
000024  ea412000          ORR      r0,r1,r0,LSL #8
;;;40         return crc;
;;;41     }
000028  bd70              POP      {r4-r6,pc}
;;;42     
                          ENDP


                          AREA ||i.im1281b_analysis_data||, CODE, EXECONLY, ALIGN=1

                  im1281b_analysis_data PROC
;;;67     
;;;68     uint8_t im1281b_analysis_data(void)
000000  b530              PUSH     {r4,r5,lr}
;;;69     {
;;;70         union crcdata
;;;71         {
;;;72             uint16_t word16;
;;;73             uint8_t byte[2];
;;;74         } crcnow;
;;;75     	
;;;76         if (USART1_RX_STA & 0x8000) //接收完成
000002  f2400500          MOVW     r5,#:LOWER16: USART1_RX_STA
000006  f2c00500          MOVT     r5,#:UPPER16: USART1_RX_STA
00000a  8828              LDRH     r0,[r5,#0]  ; USART1_RX_STA
00000c  0400              LSLS     r0,r0,#16
00000e  d55f              BPL      |L3.208|
;;;77         {
;;;78             if (USART1_RX_BUF[0] == Read_ID) //确认 ID 正确
000010  f2400400          MOVW     r4,#:LOWER16: USART1_RX_BUF
000014  f2c00400          MOVT     r4,#:UPPER16: USART1_RX_BUF
000018  7820              LDRB     r0,[r4,#0]  ; USART1_RX_BUF
00001a  2801              CMP      r0,#1
00001c  d156              BNE      |L3.204|
;;;79             {
;;;80                 crcnow.word16 = chkcrc(USART1_RX_BUF,(USART1_RX_STA & 0x3fff) - 2);
00001e  8828              LDRH     r0,[r5,#0]  ; USART1_RX_STA
000020  1e80              SUBS     r0,r0,#2
000022  b2c1              UXTB     r1,r0
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       chkcrc
;;;81                 if ((crcnow.byte[0] == USART1_RX_BUF[(USART1_RX_STA & 0x3fff) - 1]) && (crcnow.byte[1] == USART1_RX_BUF[(USART1_RX_STA & 0x3fff) - 2]))
00002a  882a              LDRH     r2,[r5,#0]  ; USART1_RX_STA
00002c  b2c1              UXTB     r1,r0                 ;80
00002e  f3c2020d          UBFX     r2,r2,#0,#14
000032  4422              ADD      r2,r2,r4
000034  f8122c01          LDRB     r2,[r2,#-1]
000038  4291              CMP      r1,r2
00003a  d147              BNE      |L3.204|
00003c  8829              LDRH     r1,[r5,#0]  ; USART1_RX_STA
00003e  0a00              LSRS     r0,r0,#8
000040  f3c1010d          UBFX     r1,r1,#0,#14
000044  4421              ADD      r1,r1,r4
000046  f8111c02          LDRB     r1,[r1,#-2]
00004a  4288              CMP      r0,r1
00004c  d13e              BNE      |L3.204|
;;;82                 //确认 CRC 校验正确
;;;83                 {
;;;84                     Voltage_data = 		(((uint32_t)(USART1_RX_BUF[3])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[4])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[5])) 	<< 8) | USART1_RX_BUF[6];
00004e  f8540f03          LDR      r0,[r4,#3]!  ; USART1_RX_BUF
000052  ba00              REV      r0,r0
000054  f02001ff          BIC      r1,r0,#0xff
000058  78e0              LDRB     r0,[r4,#3]  ; USART1_RX_BUF
00005a  4301              ORRS     r1,r1,r0
00005c  f2400000          MOVW     r0,#:LOWER16: ||.data||
000060  f2c00000          MOVT     r0,#:UPPER16: ||.data||
;;;85                     Current_data = 		(((uint32_t)(USART1_RX_BUF[7])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[8])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[9])) 	<< 8) | USART1_RX_BUF[10];
000064  6001              STR      r1,[r0,#0]  ; Voltage_data
000066  6861              LDR      r1,[r4,#4]  ; USART1_RX_BUF
000068  79e2              LDRB     r2,[r4,#7]  ; USART1_RX_BUF
00006a  ba09              REV      r1,r1
00006c  f02101ff          BIC      r1,r1,#0xff
000070  4311              ORRS     r1,r1,r2
;;;86                     Power_data = 		(((uint32_t)(USART1_RX_BUF[11])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[12])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[13])) 	<< 8) | USART1_RX_BUF[14];
000072  6041              STR      r1,[r0,#4]  ; Current_data
000074  68a1              LDR      r1,[r4,#8]  ; USART1_RX_BUF
000076  7ae2              LDRB     r2,[r4,#0xb]  ; USART1_RX_BUF
000078  ba09              REV      r1,r1
00007a  f02101ff          BIC      r1,r1,#0xff
00007e  4311              ORRS     r1,r1,r2
;;;87                     Energy_data = 		(((uint32_t)(USART1_RX_BUF[15])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[16])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[17])) 	<< 8) | USART1_RX_BUF[18];
000080  6081              STR      r1,[r0,#8]  ; Power_data
000082  68e1              LDR      r1,[r4,#0xc]  ; USART1_RX_BUF
000084  7be2              LDRB     r2,[r4,#0xf]  ; USART1_RX_BUF
000086  ba09              REV      r1,r1
000088  f02101ff          BIC      r1,r1,#0xff
00008c  4311              ORRS     r1,r1,r2
;;;88                     Pf_data = 			(((uint32_t)(USART1_RX_BUF[19])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[20])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[21])) 	<< 8) | USART1_RX_BUF[22];
00008e  60c1              STR      r1,[r0,#0xc]  ; Energy_data
000090  6921              LDR      r1,[r4,#0x10]  ; USART1_RX_BUF
000092  7ce2              LDRB     r2,[r4,#0x13]  ; USART1_RX_BUF
000094  ba09              REV      r1,r1
000096  f02101ff          BIC      r1,r1,#0xff
00009a  4311              ORRS     r1,r1,r2
;;;89                     CO2_data = 			(((uint32_t)(USART1_RX_BUF[23])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[24])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[25])) 	<< 8) | USART1_RX_BUF[26];
00009c  6101              STR      r1,[r0,#0x10]  ; Pf_data
00009e  6961              LDR      r1,[r4,#0x14]  ; USART1_RX_BUF
0000a0  7de2              LDRB     r2,[r4,#0x17]  ; USART1_RX_BUF
0000a2  ba09              REV      r1,r1
0000a4  f02101ff          BIC      r1,r1,#0xff
0000a8  4311              ORRS     r1,r1,r2
;;;90     				Temp_data = 		(((uint32_t)(USART1_RX_BUF[27])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[28])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[29])) 	<< 8) | USART1_RX_BUF[30];
0000aa  6141              STR      r1,[r0,#0x14]  ; CO2_data
0000ac  69a1              LDR      r1,[r4,#0x18]  ; USART1_RX_BUF
0000ae  7ee2              LDRB     r2,[r4,#0x1b]  ; USART1_RX_BUF
0000b0  ba09              REV      r1,r1
0000b2  f02101ff          BIC      r1,r1,#0xff
0000b6  4311              ORRS     r1,r1,r2
;;;91     				Freq_data = 		(((uint32_t)(USART1_RX_BUF[31])) 	<< 24) | (((uint32_t)(USART1_RX_BUF[32])) 	<< 16) | (((uint32_t)(USART1_RX_BUF[33])) 	<< 8) | USART1_RX_BUF[34];
0000b8  6181              STR      r1,[r0,#0x18]  ; Temp_data
0000ba  69e1              LDR      r1,[r4,#0x1c]  ; USART1_RX_BUF
0000bc  7fe2              LDRB     r2,[r4,#0x1f]  ; USART1_RX_BUF
0000be  ba09              REV      r1,r1
0000c0  f02101ff          BIC      r1,r1,#0xff
0000c4  4311              ORRS     r1,r1,r2
;;;92     				return 1;
0000c6  61c1              STR      r1,[r0,#0x1c]  ; Freq_data
0000c8  2001              MOVS     r0,#1
;;;93                 }
;;;94             }
;;;95     		USART1_RX_STA = 0;
;;;96         }
;;;97     	return 0;
;;;98     }
0000ca  bd30              POP      {r4,r5,pc}
                  |L3.204|
0000cc  2000              MOVS     r0,#0                 ;95
0000ce  8028              STRH     r0,[r5,#0]            ;95
                  |L3.208|
0000d0  2000              MOVS     r0,#0                 ;97
0000d2  bd30              POP      {r4,r5,pc}
                          ENDP


                          AREA ||i.im1281b_ask||, CODE, EXECONLY, ALIGN=1

                  im1281b_ask PROC
;;;42     
;;;43     void im1281b_ask(void)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
;;;45         union crcdata
;;;46         {
;;;47             uint16_t word16;
;;;48             uint8_t byte[2];
;;;49         } crcnow;
;;;50     	
;;;51     	Tx_Buffer[0] = Read_ID; //模块的 ID 号，默认 ID 为 0x01
000002  2001              MOVS     r0,#1
000004  f2400500          MOVW     r5,#:LOWER16: ||.data||+32
000008  f2c00500          MOVT     r5,#:UPPER16: ||.data||+32
00000c  7028              STRB     r0,[r5,#0]
;;;52     	Tx_Buffer[1] = 0x03;
00000e  2003              MOVS     r0,#3
000010  7068              STRB     r0,[r5,#1]
;;;53     	Tx_Buffer[2] = 0x00;
000012  2000              MOVS     r0,#0
000014  70a8              STRB     r0,[r5,#2]
;;;54     	Tx_Buffer[3] = 0x48;
000016  2148              MOVS     r1,#0x48
000018  70e9              STRB     r1,[r5,#3]
;;;55     	Tx_Buffer[4] = 0x00;
00001a  7128              STRB     r0,[r5,#4]
;;;56     	Tx_Buffer[5] = 0x08;
00001c  2008              MOVS     r0,#8
00001e  7168              STRB     r0,[r5,#5]
;;;57     	crcnow.word16 = chkcrc(Tx_Buffer, 6);
000020  2106              MOVS     r1,#6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       chkcrc
000028  0a01              LSRS     r1,r0,#8
;;;58     	Tx_Buffer[6] = crcnow.byte[1]; // CRC 效验低字节在前
00002a  71a9              STRB     r1,[r5,#6]
;;;59     	Tx_Buffer[7] = crcnow.byte[0];
;;;60     	
;;;61     	for (uint8_t t = 0; t < 8; t++){
;;;62     		while (USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET){} //等待发送
00002c  f44f5660          MOV      r6,#0x3800
000030  71e8              STRB     r0,[r5,#7]            ;59
000032  2400              MOVS     r4,#0                 ;61
000034  f2c40601          MOVT     r6,#0x4001
                  |L4.56|
000038  2140              MOVS     r1,#0x40
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       USART_GetFlagStatus
000040  2801              CMP      r0,#1
000042  d1f9              BNE      |L4.56|
;;;63     		USART_SendData(USART1, Tx_Buffer[t]); //向串口2发送数据
000044  5d29              LDRB     r1,[r5,r4]
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       USART_SendData
                  |L4.76|
;;;64     		while (USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET){} //等待发送
00004c  2140              MOVS     r1,#0x40
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       USART_GetFlagStatus
000054  2801              CMP      r0,#1
000056  d1f9              BNE      |L4.76|
000058  1c64              ADDS     r4,r4,#1
00005a  b2e4              UXTB     r4,r4                 ;61
00005c  2c08              CMP      r4,#8                 ;61
00005e  d3eb              BCC      |L4.56|
;;;65     	}
;;;66     }
000060  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Voltage_data
                          DCD      0x00000000
                  Current_data
                          DCD      0x00000000
                  Power_data
                          DCD      0x00000000
                  Energy_data
                          DCD      0x00000000
                  Pf_data
                          DCD      0x00000000
                  CO2_data
                          DCD      0x00000000
                  Temp_data
                          DCD      0x00000000
                  Freq_data
                          DCD      0x00000000
                  Tx_Buffer
                          %        8
