; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --execute_only --list --split_sections --debug -c --asm --interleave -o..\obj\bsptime.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\bsptime.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\KEY -I..\HARDWARE\TIMER -I..\SYSTEM\bsptime -I..\SYSTEM\IM1281B -I.\RTE\_PWM -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=527 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\bsptime.crf ..\SYSTEM\bsptime\BspTime.c]
                          THUMB

                          AREA ||i.delay_ms||, CODE, EXECONLY, ALIGN=1

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  delay_ms PROC
;;;18     
;;;19     void delay_ms(uint16_t nms){
000000  4604              MOV      r4,r0
;;;20     	setTimer(delaytimer,0);
000002  2100              MOVS     r1,#0
000004  f2400500          MOVW     r5,#:LOWER16: ||.data||
000008  f2c00500          MOVT     r5,#:UPPER16: ||.data||
00000c  6828              LDR      r0,[r5,#0]  ; delaytimer
00000e  f7fffffe          BL       setTimer
                  |L1.18|
;;;21     	while(1){
;;;22     		printf("%d",IS_INTIME_MS(delaytimer,nms));
000012  6828              LDR      r0,[r5,#0]  ; delaytimer
000014  8800              LDRH     r0,[r0,#0]
000016  42a0              CMP      r0,r4
000018  d801              BHI      |L1.30|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  2100              MOVS     r1,#0
                  |L1.32|
000020  f2400000          MOVW     r0,#:LOWER16: ||.conststring||
000024  f2c00000          MOVT     r0,#:UPPER16: ||.conststring||
000028  f7fffffe          BL       __2printf
00002c  e7f1              B        |L1.18|
;;;23     	}
;;;24     }
;;;25     
                          ENDP


                          AREA ||i.init_bsptimer||, CODE, EXECONLY, ALIGN=1

                  init_bsptimer PROC
;;;7      //初始化相关定时器和中断
;;;8      void init_bsptimer(void){
000000  f04f20e0          MOV      r0,#0xe000e000
;;;9      	SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8; 
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210104          BIC      r1,r1,#4
00000a  6101              STR      r1,[r0,#0x10]
;;;10     	SysTick->LOAD=SystemCoreClock/8000; 		//时间加载	  		 
00000c  f2400100          MOVW     r1,#:LOWER16: SystemCoreClock
000010  f2c00100          MOVT     r1,#:UPPER16: SystemCoreClock
000014  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000016  f44f52fa          MOV      r2,#0x1f40
00001a  fbb1f1f2          UDIV     r1,r1,r2
00001e  6141              STR      r1,[r0,#0x14]
;;;11     	SysTick->VAL=0x00;        					//清空计数器
000020  2100              MOVS     r1,#0
000022  6181              STR      r1,[r0,#0x18]
;;;12     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk ;	//启用中断
000024  6901              LDR      r1,[r0,#0x10]
000026  f0410102          ORR      r1,r1,#2
00002a  6101              STR      r1,[r0,#0x10]
;;;13     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;	//开始倒数
00002c  6901              LDR      r1,[r0,#0x10]
00002e  f0410101          ORR      r1,r1,#1
000032  6101              STR      r1,[r0,#0x10]
;;;14     	if(delaytimer != NULL){
000034  f2400000          MOVW     r0,#:LOWER16: ||.data||
000038  f2c00000          MOVT     r0,#:UPPER16: ||.data||
00003c  6800              LDR      r0,[r0,#0]  ; delaytimer
00003e  2800              CMP      r0,#0                 ;8
000040  d001              BEQ      |L2.70|
;;;15     		delaytimer->busy = 1;
000042  2101              MOVS     r1,#1
000044  7081              STRB     r1,[r0,#2]
                  |L2.70|
;;;16     	}
;;;17     }
000046  4770              BX       lr
;;;18     
                          ENDP


                          AREA ||i.obtainTimer||, CODE, EXECONLY, ALIGN=1

                  obtainTimer PROC
;;;30     */
;;;31     autotimer* obtainTimer(uint16_t start_value) {
000000  2100              MOVS     r1,#0
;;;32         uint8_t i;
;;;33         for (i = 0; i < TIMER_COUNT; i++) {
;;;34             if (bsptimers[i].busy == 0) {
000002  f2400200          MOVW     r2,#:LOWER16: ||.bss||
000006  f2c00200          MOVT     r2,#:UPPER16: ||.bss||
                  |L3.10|
00000a  eb020381          ADD      r3,r2,r1,LSL #2
00000e  789b              LDRB     r3,[r3,#2]
000010  b133              CBZ      r3,|L3.32|
000012  1c49              ADDS     r1,r1,#1
000014  b2c9              UXTB     r1,r1                 ;33
000016  290a              CMP      r1,#0xa               ;33
000018  d3f7              BCC      |L3.10|
                  |L3.26|
;;;35                 bsptimers[i].time = start_value;
;;;36                 bsptimers[i].busy = 1;
;;;37                 break;
;;;38             }
;;;39         }
;;;40         return &bsptimers[i];
00001a  eb020081          ADD      r0,r2,r1,LSL #2
;;;41     }
00001e  4770              BX       lr
                  |L3.32|
000020  f8220021          STRH     r0,[r2,r1,LSL #2]     ;35
000024  eb020381          ADD      r3,r2,r1,LSL #2       ;36
000028  2001              MOVS     r0,#1                 ;36
00002a  7098              STRB     r0,[r3,#2]            ;36
00002c  e7f5              B        |L3.26|
;;;42     /*
                          ENDP


                          AREA ||i.returnTimer||, CODE, EXECONLY, ALIGN=1

                  returnTimer PROC
;;;53     */
;;;54     void returnTimer(autotimer* timer) {
000000  2100              MOVS     r1,#0
;;;55         timer->busy = 0;
000002  7081              STRB     r1,[r0,#2]
;;;56         timer->time = 0;
000004  8001              STRH     r1,[r0,#0]
;;;57     }
000006  4770              BX       lr
;;;58     
                          ENDP


                          AREA ||i.setTimer||, CODE, EXECONLY, ALIGN=1

                  setTimer PROC
;;;44     */
;;;45     uint8_t setTimer(autotimer* timer,uint16_t start_value) {
000000  7882              LDRB     r2,[r0,#2]
000002  b112              CBZ      r2,|L5.10|
;;;46         if(timer->busy == 0)return 0;
;;;47         timer->time = start_value;
000004  8001              STRH     r1,[r0,#0]
;;;48         return 1;
000006  2001              MOVS     r0,#1
;;;49     }
000008  4770              BX       lr
                  |L5.10|
00000a  2000              MOVS     r0,#0                 ;46
00000c  4770              BX       lr
;;;50     /*
                          ENDP


                          AREA ||i.tickingTimer||, CODE, EXECONLY, ALIGN=1

                  tickingTimer PROC
;;;61     */
;;;62     void tickingTimer(void) {
000000  2000              MOVS     r0,#0
;;;63         uint8_t i;
;;;64         for (i = 0; i <= TIMER_COUNT; i++) {
;;;65             if (bsptimers[i].busy == 1) {
000002  f2400100          MOVW     r1,#:LOWER16: ||.bss||
000006  f2c00100          MOVT     r1,#:UPPER16: ||.bss||
                  |L6.10|
00000a  eb010280          ADD      r2,r1,r0,LSL #2
00000e  7892              LDRB     r2,[r2,#2]
000010  2a01              CMP      r2,#1
000012  d104              BNE      |L6.30|
;;;66                 bsptimers[i].time += 1;
000014  f8312020          LDRH     r2,[r1,r0,LSL #2]
000018  1c52              ADDS     r2,r2,#1
00001a  f8212020          STRH     r2,[r1,r0,LSL #2]
                  |L6.30|
00001e  1c40              ADDS     r0,r0,#1
000020  b2c0              UXTB     r0,r0                 ;64
000022  280a              CMP      r0,#0xa               ;64
000024  d9f1              BLS      |L6.10|
;;;67             }
;;;68         }
;;;69     }
000026  4770              BX       lr
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  bsptimers
                          %        44

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  256400            DCB      "%d",0

                          AREA ||.data||, DATA, ALIGN=2

                  delaytimer
                          DCD      bsptimers+0x28
